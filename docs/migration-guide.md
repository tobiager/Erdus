# Database Migration with Erdus

Erdus now supports engine-agnostic database migrations generated from IR (Intermediate Representation) diffs. This enables cross-engine workflows like migrating from SQL Server to PostgreSQL/Supabase.

## Overview

The migration system works in two stages:

1. **Diff Generation**: Compare two IR JSON files to generate a migration plan
2. **Migration Rendering**: Convert the migration plan to SQL DDL for your target database

This approach ensures that:
- IR serves as the single source of truth
- Migrations are engine-agnostic until rendering
- Type mappings are handled automatically for different dialects
- Migration plans are stable and reproducible

## Commands

### Generate Migration Plan

```bash
erdus diff --old old.ir.json --new new.ir.json --out plan.migration.json
```

Compares two IR schemas and generates a JSON migration plan with operations like:
- Add/drop tables and columns
- Rename tables and columns (with smart heuristics)
- Alter column types and constraints
- Add/drop foreign keys and indexes

### Render Migration SQL

```bash
erdus render:migration --plan plan.migration.json --dialect postgres --out migration.sql
```

Supported dialects:
- `postgres` - PostgreSQL/Supabase
- `sqlserver` - Microsoft SQL Server
- `mysql` - MySQL
- `sqlite` - SQLite

## Type Mappings

### SQL Server → PostgreSQL

| SQL Server | PostgreSQL |
|------------|------------|
| `INT IDENTITY` | `INTEGER GENERATED BY DEFAULT AS IDENTITY` |
| `NVARCHAR(n)` | `VARCHAR(n)` |
| `NVARCHAR(MAX)` | `TEXT` |
| `BIT` | `BOOLEAN` |
| `DATETIME2` | `TIMESTAMP WITHOUT TIME ZONE` |
| `UNIQUEIDENTIFIER` | `UUID` |
| `GETDATE()` | `now()` |
| `NEWID()` | `gen_random_uuid()` |

### PostgreSQL → SQL Server

| PostgreSQL | SQL Server |
|------------|------------|
| `INTEGER` | `INT` |
| `VARCHAR(n)` | `NVARCHAR(n)` |
| `TEXT` | `NVARCHAR(MAX)` |
| `BOOLEAN` | `BIT` |
| `TIMESTAMP WITHOUT TIME ZONE` | `DATETIME2` |
| `UUID` | `UNIQUEIDENTIFIER` |
| `now()` | `GETDATE()` |
| `gen_random_uuid()` | `NEWID()` |

## Migration Plan Structure

A migration plan is a JSON file with this structure:

```json
{
  "version": "1.0",
  "operations": [
    {
      "type": "renameTable",
      "table": "Users",
      "newName": "users"
    },
    {
      "type": "addColumn",
      "table": "users",
      "column": "full_name",
      "columnDef": {
        "name": "full_name",
        "type": "VARCHAR(100)",
        "isOptional": true
      }
    },
    {
      "type": "alterColumn",
      "table": "users",
      "column": "email",
      "columnDef": {
        "name": "email",
        "type": "VARCHAR(150)",
        "isOptional": false
      }
    }
  ]
}
```

### Operation Types

- `addTable` / `dropTable` - Create or remove tables
- `addColumn` / `dropColumn` - Add or remove columns
- `alterColumn` - Change column type, nullability, or defaults
- `renameColumn` / `renameTable` - Rename columns or tables
- `addForeignKey` / `dropForeignKey` - Foreign key constraints
- `addIndex` / `dropIndex` - Database indexes

## Smart Rename Detection

The diff algorithm includes heuristics to detect renames:

- **Case Changes**: `UserId` → `user_id`
- **Naming Conventions**: `PascalCase` ↔ `snake_case`
- **Similar Types**: Columns with same type and constraints

## Example Workflow: SQL Server to Supabase

1. **Export your SQL Server schema to IR**:
   ```bash
   erdus convert schema.sql ir > mssql.ir.json
   ```

2. **Create your target PostgreSQL IR** (manually or convert from existing schema):
   ```json
   {
     "tables": [
       {
         "name": "users",
         "columns": [
           {
             "name": "id",
             "type": "INTEGER",
             "isPrimaryKey": true,
             "default": "autoincrement()"
           }
         ]
       }
     ]
   }
   ```

3. **Generate migration plan**:
   ```bash
   erdus diff --old mssql.ir.json --new postgres.ir.json --out plan.json
   ```

4. **Render PostgreSQL migration**:
   ```bash
   erdus render:migration --plan plan.json --dialect postgres --out migration.sql
   ```

5. **Apply to Supabase**:
   ```sql
   -- Copy the contents of migration.sql to Supabase SQL Editor
   ```

## Operation Ordering

Operations are automatically ordered to handle dependencies:

1. Drop foreign keys
2. Drop indexes
3. Drop columns
4. Drop tables
5. Add tables
6. Add columns
7. Alter columns
8. Rename columns/tables
9. Add indexes
10. Add foreign keys

## PostgreSQL Specifics

For PostgreSQL migrations, the renderer:
- Uses `USING` clauses for type conversions
- Separates `ALTER COLUMN` operations (type, nullability, defaults)
- Properly handles `GENERATED BY DEFAULT AS IDENTITY`
- Maps SQL Server types to PostgreSQL equivalents

## SQL Server Specifics

For SQL Server migrations, the renderer:
- Uses bracketed identifiers `[table]`
- Combines column changes into single `ALTER COLUMN` statements
- Uses `EXEC sp_rename` for column renames
- Maps PostgreSQL types to SQL Server equivalents

This migration system provides a robust foundation for database schema evolution across different engines while maintaining the IR as the single source of truth.