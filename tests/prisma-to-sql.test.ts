import { describe, it, expect } from 'vitest';
import { prismaToIR } from '../src/prisma-to-ir';
import { irToPostgres } from '../src/ir-to-sql';

const schema = `
model Usuario {
  id Int @id @default(autoincrement())
  nombre String
  roles UsuarioRol[]
}

model Rol {
  id Int @id @default(autoincrement())
  nombre String @unique
  usuarios UsuarioRol[]
}

model UsuarioRol {
  usuario_id Int
  rol_id Int
  usuario Usuario @relation(fields: [usuario_id], references: [id])
  rol Rol @relation(fields: [rol_id], references: [id])
  @@id([usuario_id, rol_id])
}
`;

describe('Prisma to SQL', () => {
  const ir = prismaToIR(schema);
  const sql = irToPostgres(ir);

  it('matches expected snapshot', () => {
    expect(sql).toMatchInlineSnapshot(`
      "CREATE TABLE "Usuario" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "nombre" VARCHAR(255) NOT NULL
      );
      CREATE TABLE "Rol" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "nombre" VARCHAR(255) NOT NULL UNIQUE
      );
      CREATE TABLE "UsuarioRol" (
        "usuario_id" INT NOT NULL,
        "rol_id" INT NOT NULL,
        PRIMARY KEY ("usuario_id","rol_id"),
        FOREIGN KEY ("usuario_id") REFERENCES "Usuario"("id"),
        FOREIGN KEY ("rol_id") REFERENCES "Rol"("id")
      );"
    `);
  });

  it('does not emit object typed columns for join table', () => {
    const join = /CREATE TABLE "UsuarioRol"([\s\S]*?)\);/.exec(sql)?.[1] || '';
    expect(join).not.toMatch(/"usuario"/);
    expect(join).not.toMatch(/"rol"/);
  });

  it('has composite primary key', () => {
    expect(sql).toContain('PRIMARY KEY ("usuario_id","rol_id")');
  });

  it('maps types and identity columns', () => {
    expect(sql).toContain('"id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
    expect(sql).toContain('"nombre" VARCHAR(255) NOT NULL');
  });
});
