import type { IRDiagram, IRColumn } from './ir';

export interface DbmlOptions {
  /** Whether to include comments in the output. */
  includeComments?: boolean;
}

/**
 * Convert canonical IR to DBML format.
 * DBML (Database Markup Language) is used by dbdiagram.io
 */
export function irToDbml(diagram: IRDiagram, opts: DbmlOptions = {}): string {
  const lines: string[] = [];
  
  if (opts.includeComments) {
    lines.push('// Generated by Erdus - Universal ER Diagram Converter');
    lines.push('// https://erdus-inky.vercel.app');
    lines.push('');
  }

  // Convert each table
  for (const table of diagram.tables) {
    lines.push(`Table ${table.name} {`);
    
    // Add columns
    for (const col of table.columns) {
      const colLine = convertColumn(col);
      lines.push(`  ${colLine}`);
    }
    
    lines.push('}');
    lines.push('');
  }

  // Add relationships
  const relationships = extractRelationships(diagram);
  if (relationships.length > 0) {
    for (const rel of relationships) {
      lines.push(rel);
    }
    lines.push('');
  }

  return lines.join('\n').trim();
}

function convertColumn(col: IRColumn): string {
  let line = `${col.name} ${mapType(col)}`;
  
  const attributes: string[] = [];
  
  if (col.isPrimaryKey) {
    attributes.push('pk');
  }
  
  if (col.isUnique && !col.isPrimaryKey) {
    attributes.push('unique');
  }
  
  // Primary keys are implicitly NOT NULL in DBML, so we don't need to add it
  if (!col.isOptional && !col.isPrimaryKey) {
    attributes.push('not null');
  }
  
  if (col.default && col.default !== 'autoincrement()') {
    attributes.push(`default: '${col.default}'`);
  }
  
  if (col.default === 'autoincrement()') {
    attributes.push('increment');
  }
  
  if (attributes.length > 0) {
    line += ` [${attributes.join(', ')}]`;
  }
  
  return line;
}

function mapType(col: IRColumn): string {
  // Map common IR types to DBML types
  switch (col.type) {
    case 'Int':
      return col.default === 'autoincrement()' ? 'int' : 'int';
    case 'String':
      return 'varchar';
    case 'DateTime':
      return 'timestamp';
    case 'Boolean':
      return 'boolean';
    case 'Float':
      return 'decimal';
    case 'Double':
      return 'decimal';
    default:
      // For SQL types, try to map them appropriately
      const lowerType = col.type.toLowerCase();
      if (lowerType.includes('varchar') || lowerType.includes('text')) {
        return 'varchar';
      }
      if (lowerType.includes('int') || lowerType.includes('serial')) {
        return 'int';
      }
      if (lowerType.includes('timestamp') || lowerType.includes('datetime')) {
        return 'timestamp';
      }
      if (lowerType.includes('boolean') || lowerType.includes('bool')) {
        return 'boolean';
      }
      if (lowerType.includes('decimal') || lowerType.includes('numeric') || lowerType.includes('float') || lowerType.includes('double')) {
        return 'decimal';
      }
      // Default fallback
      return col.type;
  }
}

function extractRelationships(diagram: IRDiagram): string[] {
  const relationships: string[] = [];
  
  for (const table of diagram.tables) {
    for (const col of table.columns) {
      if (col.references) {
        // DBML relationship syntax: Ref: table.column > referenced_table.referenced_column
        const relationship = `Ref: ${table.name}.${col.name} > ${col.references.table}.${col.references.column}`;
        relationships.push(relationship);
      }
    }
  }
  
  return relationships;
}