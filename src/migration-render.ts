import type { MigrationPlan, MigrationOperation } from './migration';
import type { IRColumn } from './ir';

export type SqlDialect = 'postgres' | 'sqlserver' | 'mysql' | 'sqlite';

/**
 * Render a migration plan to SQL DDL for the specified dialect
 */
export function renderMigration(plan: MigrationPlan, dialect: SqlDialect, fullTableDefinitions?: Map<string, any>): string {
  const statements: string[] = [];

  for (const operation of plan.operations) {
    const sql = renderOperation(operation, dialect, fullTableDefinitions);
    if (sql) {
      statements.push(sql);
    }
  }

  return statements.join('\n\n');
}

/**
 * Render a single migration operation to SQL
 */
function renderOperation(operation: MigrationOperation, dialect: SqlDialect, fullTableDefinitions?: Map<string, any>): string {
  switch (operation.type) {
    case 'addTable':
      // For now, we'll just add a comment - full table creation would need the complete table definition
      return `-- TODO: CREATE TABLE ${quoteIdentifier(operation.table, dialect)} - table definition not included in migration plan`;
    
    case 'dropTable':
      return `DROP TABLE ${quoteIdentifier(operation.table, dialect)};`;
    
    case 'addColumn':
      if (!operation.columnDef) return '';
      return `ALTER TABLE ${quoteIdentifier(operation.table, dialect)} ADD COLUMN ${renderColumnDefinition(operation.columnDef, dialect)};`;
    
    case 'dropColumn':
      return `ALTER TABLE ${quoteIdentifier(operation.table, dialect)} DROP COLUMN ${quoteIdentifier(operation.column!, dialect)};`;
    
    case 'alterColumn':
      if (!operation.columnDef) return '';
      return renderAlterColumn(operation.table, operation.column!, operation.columnDef, dialect);
    
    case 'renameColumn':
      return renderRenameColumn(operation.table, operation.column!, operation.newName!, dialect);
    
    case 'renameTable':
      return `ALTER TABLE ${quoteIdentifier(operation.table, dialect)} RENAME TO ${quoteIdentifier(operation.newName!, dialect)};`;
    
    case 'addForeignKey':
      if (!operation.foreignKey) return '';
      return renderAddForeignKey(operation.table, operation.foreignKey, dialect);
    
    case 'dropForeignKey':
      if (!operation.foreignKey) return '';
      return renderDropForeignKey(operation.table, operation.foreignKey, dialect);
    
    case 'addIndex':
      if (!operation.indexDef) return '';
      return renderAddIndex(operation.table, operation.indexDef, dialect);
    
    case 'dropIndex':
      if (!operation.indexDef) return '';
      return renderDropIndex(operation.table, operation.indexDef, dialect);
    
    default:
      return '';
  }
}

/**
 * Render a column definition for CREATE/ALTER statements
 */
function renderColumnDefinition(column: IRColumn, dialect: SqlDialect): string {
  const name = quoteIdentifier(column.name, dialect);
  const type = mapColumnType(column, dialect);
  
  let definition = `${name} ${type}`;
  
  // Handle identity/auto-increment
  if (column.isPrimaryKey && column.default === 'autoincrement()' && column.type === 'Int') {
    if (dialect === 'postgres') {
      definition += ' GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY';
      return definition;
    } else if (dialect === 'sqlserver') {
      definition += ' IDENTITY(1,1) PRIMARY KEY';
      return definition;
    }
  }
  
  // Handle NOT NULL
  if (!column.isOptional) {
    definition += ' NOT NULL';
  }
  
  // Handle defaults (excluding autoincrement)
  if (column.default && column.default !== 'autoincrement()') {
    const defaultValue = mapDefaultValue(column.default, dialect);
    definition += ` DEFAULT ${defaultValue}`;
  }
  
  // Handle UNIQUE
  if (column.isUnique && !column.isPrimaryKey) {
    definition += ' UNIQUE';
  }
  
  return definition;
}

/**
 * Map column types between dialects
 */
function mapColumnType(column: IRColumn, dialect: SqlDialect): string {
  const sourceType = column.type.toLowerCase();
  
  if (dialect === 'postgres') {
    // SQL Server → PostgreSQL mappings
    if (sourceType === 'int' || sourceType === 'integer') return 'INTEGER';
    if (sourceType.startsWith('nvarchar')) {
      const match = sourceType.match(/nvarchar\((\d+)\)/);
      return match ? `VARCHAR(${match[1]})` : 'TEXT';
    }
    if (sourceType.startsWith('varchar')) return sourceType.toUpperCase();
    if (sourceType === 'bit') return 'BOOLEAN';
    if (sourceType === 'datetime' || sourceType === 'datetime2') return 'TIMESTAMP WITHOUT TIME ZONE';
    if (sourceType === 'uniqueidentifier') return 'UUID';
    if (sourceType === 'text') return 'TEXT';
    if (sourceType === 'float') return 'REAL';
    if (sourceType === 'double') return 'DOUBLE PRECISION';
    
    // Generic type mappings
    if (column.type === 'Int') return 'INTEGER';
    if (column.type === 'String') return 'TEXT';
    if (column.type === 'Boolean') return 'BOOLEAN';
    if (column.type === 'DateTime') return 'TIMESTAMP WITHOUT TIME ZONE';
    
    return column.type;
  }
  
  if (dialect === 'sqlserver') {
    // PostgreSQL → SQL Server mappings
    if (sourceType === 'integer') return 'INT';
    if (sourceType.startsWith('varchar')) return sourceType.replace('varchar', 'NVARCHAR');
    if (sourceType === 'text') return 'NVARCHAR(MAX)';
    if (sourceType === 'boolean') return 'BIT';
    if (sourceType === 'timestamp without time zone') return 'DATETIME2';
    if (sourceType === 'uuid') return 'UNIQUEIDENTIFIER';
    if (sourceType === 'real') return 'FLOAT';
    if (sourceType === 'double precision') return 'FLOAT';
    
    // Generic type mappings
    if (column.type === 'Int') return 'INT';
    if (column.type === 'String') return 'NVARCHAR(255)';
    if (column.type === 'Boolean') return 'BIT';
    if (column.type === 'DateTime') return 'DATETIME2';
    
    return column.type;
  }
  
  // Default fallback
  return column.type;
}

/**
 * Map default values between dialects
 */
function mapDefaultValue(defaultValue: string, dialect: SqlDialect): string {
  const lowerDefault = defaultValue.toLowerCase();
  
  if (dialect === 'postgres') {
    if (lowerDefault === 'getdate()') return 'now()';
    if (lowerDefault === 'newid()') return 'gen_random_uuid()';
  }
  
  if (dialect === 'sqlserver') {
    if (lowerDefault === 'now()') return 'GETDATE()';
    if (lowerDefault === 'gen_random_uuid()') return 'NEWID()';
  }
  
  return defaultValue;
}

/**
 * Render ALTER COLUMN statement (varies significantly by dialect)
 */
function renderAlterColumn(tableName: string, columnName: string, columnDef: IRColumn, dialect: SqlDialect): string {
  const table = quoteIdentifier(tableName, dialect);
  const column = quoteIdentifier(columnName, dialect);
  const newType = mapColumnType(columnDef, dialect);
  
  if (dialect === 'postgres') {
    // PostgreSQL uses separate ALTER statements for different changes
    const statements: string[] = [];
    
    // Change type (with USING clause for type conversion)
    statements.push(`ALTER TABLE ${table} ALTER COLUMN ${column} TYPE ${newType} USING ${column}::${newType}`);
    
    // Change nullability
    if (columnDef.isOptional) {
      statements.push(`ALTER TABLE ${table} ALTER COLUMN ${column} DROP NOT NULL`);
    } else {
      statements.push(`ALTER TABLE ${table} ALTER COLUMN ${column} SET NOT NULL`);
    }
    
    // Change default
    if (columnDef.default && columnDef.default !== 'autoincrement()') {
      const defaultValue = mapDefaultValue(columnDef.default, dialect);
      statements.push(`ALTER TABLE ${table} ALTER COLUMN ${column} SET DEFAULT ${defaultValue}`);
    } else {
      statements.push(`ALTER TABLE ${table} ALTER COLUMN ${column} DROP DEFAULT`);
    }
    
    return statements.join(';\n');
  }
  
  if (dialect === 'sqlserver') {
    // SQL Server ALTER COLUMN
    let definition = `ALTER TABLE ${table} ALTER COLUMN ${column} ${newType}`;
    
    if (!columnDef.isOptional) {
      definition += ' NOT NULL';
    }
    
    return definition + ';';
  }
  
  return `ALTER TABLE ${table} MODIFY COLUMN ${column} ${newType};`;
}

/**
 * Render RENAME COLUMN statement
 */
function renderRenameColumn(tableName: string, oldName: string, newName: string, dialect: SqlDialect): string {
  const table = quoteIdentifier(tableName, dialect);
  const oldCol = quoteIdentifier(oldName, dialect);
  const newCol = quoteIdentifier(newName, dialect);
  
  if (dialect === 'postgres') {
    return `ALTER TABLE ${table} RENAME COLUMN ${oldCol} TO ${newCol};`;
  }
  
  if (dialect === 'sqlserver') {
    return `EXEC sp_rename '${tableName}.${oldName}', '${newName}', 'COLUMN';`;
  }
  
  return `ALTER TABLE ${table} RENAME COLUMN ${oldCol} TO ${newCol};`;
}

/**
 * Render ADD FOREIGN KEY statement
 */
function renderAddForeignKey(tableName: string, foreignKey: { column: string; references: { table: string; column: string; onDelete?: string; onUpdate?: string } }, dialect: SqlDialect): string {
  const table = quoteIdentifier(tableName, dialect);
  const column = quoteIdentifier(foreignKey.column, dialect);
  const refTable = quoteIdentifier(foreignKey.references.table, dialect);
  const refColumn = quoteIdentifier(foreignKey.references.column, dialect);
  
  let sql = `ALTER TABLE ${table} ADD CONSTRAINT FK_${tableName}_${foreignKey.column} FOREIGN KEY (${column}) REFERENCES ${refTable}(${refColumn})`;
  
  if (foreignKey.references.onDelete) {
    sql += ` ON DELETE ${foreignKey.references.onDelete}`;
  }
  
  if (foreignKey.references.onUpdate) {
    sql += ` ON UPDATE ${foreignKey.references.onUpdate}`;
  }
  
  return sql + ';';
}

/**
 * Render DROP FOREIGN KEY statement
 */
function renderDropForeignKey(tableName: string, foreignKey: { column: string; references: { table: string; column: string } }, dialect: SqlDialect): string {
  const table = quoteIdentifier(tableName, dialect);
  const constraintName = `FK_${tableName}_${foreignKey.column}`;
  
  if (dialect === 'sqlserver') {
    return `ALTER TABLE ${table} DROP CONSTRAINT ${constraintName};`;
  }
  
  return `ALTER TABLE ${table} DROP CONSTRAINT ${constraintName};`;
}

/**
 * Render ADD INDEX statement
 */
function renderAddIndex(tableName: string, indexDef: { columns: string[]; unique?: boolean }, dialect: SqlDialect): string {
  const table = quoteIdentifier(tableName, dialect);
  const columns = indexDef.columns.map(col => quoteIdentifier(col, dialect)).join(', ');
  const indexName = `IX_${tableName}_${indexDef.columns.join('_')}`;
  const unique = indexDef.unique ? 'UNIQUE ' : '';
  
  return `CREATE ${unique}INDEX ${indexName} ON ${table} (${columns});`;
}

/**
 * Render DROP INDEX statement
 */
function renderDropIndex(tableName: string, indexDef: { columns: string[]; unique?: boolean }, dialect: SqlDialect): string {
  const indexName = `IX_${tableName}_${indexDef.columns.join('_')}`;
  
  if (dialect === 'sqlserver') {
    return `DROP INDEX ${indexName} ON ${quoteIdentifier(tableName, dialect)};`;
  }
  
  return `DROP INDEX ${indexName};`;
}

/**
 * Quote identifiers based on dialect
 */
function quoteIdentifier(identifier: string, dialect: SqlDialect): string {
  if (dialect === 'postgres') {
    return `"${identifier}"`;
  }
  
  if (dialect === 'sqlserver') {
    return `[${identifier}]`;
  }
  
  if (dialect === 'mysql') {
    return `\`${identifier}\``;
  }
  
  // sqlite
  return `"${identifier}"`;
}