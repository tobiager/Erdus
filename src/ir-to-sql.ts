import type { IRDiagram, IRColumn } from './ir';

export interface SqlOptions {
  /** Default length for VARCHAR when mapping from Prisma String. */
  stringDefaultLength?: number;
}

/** Convert canonical IR to PostgreSQL DDL. */
export function irToPostgres(diagram: IRDiagram, opts: SqlOptions = {}): string {
  const tableStmts: string[] = [];

  const mapType = (col: IRColumn): string => {
    if (col.type === 'Int') return 'INT';
    if (col.type === 'String') return `VARCHAR(${opts.stringDefaultLength ?? 255})`;
    return col.type;
  };

  for (const table of diagram.tables) {
    const lines: string[] = [];
    const fkCols: IRColumn[] = [];

    for (const col of table.columns) {
      const sqlType = mapType(col);
      let line = `  "${col.name}" ${sqlType}`;
      if (col.isPrimaryKey && col.default === 'autoincrement()' && col.type === 'Int') {
        line += ' GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY';
      } else {
        if (!col.isOptional) line += ' NOT NULL';
        if (col.isUnique && !col.isPrimaryKey) line += ' UNIQUE';
      }
      lines.push(line);
      if (col.references) fkCols.push(col);
    }

    let pkCols = table.primaryKey
      ? table.primaryKey.map(c => `"${c}"`)
      : table.columns
          .filter(
            c =>
              c.isPrimaryKey &&
              !(c.type === 'Int' && c.default === 'autoincrement()')
          )
          .map(c => `"${c.name}"`);

    if (!pkCols.length && fkCols.length === table.columns.length && fkCols.length === 2) {
      pkCols = fkCols.map(c => `"${c.name}"`);
    }

    if (pkCols.length) {
      lines.push(`  PRIMARY KEY (${pkCols.join(',')})`);
    }

    for (const col of fkCols) {
      lines.push(
        `  FOREIGN KEY ("${col.name}") REFERENCES "${col.references!.table}"("${col.references!.column}")`
      );
    }

    tableStmts.push(`CREATE TABLE "${table.name}" (\n${lines.join(',\n')}\n);`);
  }

  return tableStmts.join('\n');
}

