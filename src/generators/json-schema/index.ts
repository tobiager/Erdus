import type { IRSchema, IREntity, IRAttribute } from '../../ir';
import { validateIRSchema } from '../../ir/validators';

export interface JSONSchemaProperty {
  type: string | string[];
  format?: string;
  maxLength?: number;
  minimum?: number;
  maximum?: number;
  default?: any;
  enum?: string[];
  items?: JSONSchemaProperty;
  properties?: Record<string, JSONSchemaProperty>;
  'x-unique'?: boolean;
  'x-foreignKey'?: {
    table: string;
    column: string;
    onDelete?: string;
    onUpdate?: string;
  };
}

export interface JSONSchema {
  $schema: string;
  $id?: string;
  type: 'object';
  title: string;
  description?: string;
  properties: Record<string, JSONSchemaProperty>;
  required?: string[];
  additionalProperties?: boolean;
}

export interface JSONSchemaOptions {
  $idPrefix?: string;
  target?: 'openapi' | 'ajv';
  includeRequired?: boolean;
  includeExtensions?: boolean;
}

/**
 * Convert IR Schema to JSON Schema format
 */
export function toJSONSchema(
  ir: IRSchema,
  options: JSONSchemaOptions = {}
): Record<string, JSONSchema> {
  const validated = validateIRSchema(ir);
  const { 
    $idPrefix = '', 
    target = 'ajv',
    includeRequired = true,
    includeExtensions = true
  } = options;

  const schemas: Record<string, JSONSchema> = {};

  for (const entity of validated.entities) {
    const schema = entityToJSONSchema(entity, {
      $idPrefix,
      target,
      includeRequired,
      includeExtensions
    });
    schemas[entity.name] = schema;
  }

  return schemas;
}

function entityToJSONSchema(
  entity: IREntity,
  options: JSONSchemaOptions
): JSONSchema {
  const { $idPrefix, includeRequired, includeExtensions } = options;
  
  const properties: Record<string, JSONSchemaProperty> = {};
  const required: string[] = [];

  for (const attr of entity.attributes || entity.columns) {
    const property = attributeToJSONSchemaProperty(attr, {
      includeExtensions
    });
    
    properties[attr.name] = property;
    
    // Add to required if not nullable/optional and not primary key with auto-generation
    if (includeRequired && !attr.isOptional && !isAutoGenerated(attr)) {
      required.push(attr.name);
    }
  }

  const schema: JSONSchema = {
    $schema: 'https://json-schema.org/draft/2020-12/schema',
    type: 'object',
    title: entity.name,
    properties,
    additionalProperties: false
  };

  if ($idPrefix) {
    schema.$id = `${$idPrefix}${entity.name}`;
  }

  if (required.length > 0) {
    schema.required = required;
  }

  return schema;
}

function attributeToJSONSchemaProperty(
  attr: IRAttribute,
  options: { includeExtensions?: boolean }
): JSONSchemaProperty {
  const { includeExtensions } = options;
  const property: JSONSchemaProperty = mapTypeToJSONSchema(attr.type);

  // Handle nullable
  if (attr.isOptional) {
    if (Array.isArray(property.type)) {
      property.type = [...property.type, 'null'];
    } else {
      property.type = [property.type as string, 'null'];
    }
  }

  // Handle default values
  if (attr.default !== undefined) {
    property.default = parseDefaultValue(attr.default, property.type);
  }

  // Handle unique constraint (extension)
  if (includeExtensions && attr.isUnique) {
    property['x-unique'] = true;
  }

  // Handle foreign key reference (extension)
  if (includeExtensions && attr.references) {
    property['x-foreignKey'] = {
      table: attr.references.table,
      column: attr.references.column,
      onDelete: attr.references.onDelete,
      onUpdate: attr.references.onUpdate
    };
  }

  return property;
}

function mapTypeToJSONSchema(sqlType: string): JSONSchemaProperty {
  const type = sqlType.toLowerCase().trim();

  // String types
  if (type.includes('varchar') || type.includes('char') || type.includes('text')) {
    const lengthMatch = type.match(/\((\d+)\)/);
    const property: JSONSchemaProperty = { type: 'string' };
    
    if (lengthMatch) {
      property.maxLength = parseInt(lengthMatch[1], 10);
    }
    
    return property;
  }

  // UUID
  if (type.includes('uuid')) {
    return {
      type: 'string',
      format: 'uuid'
    };
  }

  // Email (if type hints at it)
  if (type.includes('email')) {
    return {
      type: 'string',
      format: 'email'
    };
  }

  // Integer types
  if (type.includes('int') || type.includes('serial')) {
    if (type.includes('big')) {
      return {
        type: 'integer',
        minimum: -9223372036854775000,
        maximum: 9223372036854775000
      };
    }
    if (type.includes('small')) {
      return {
        type: 'integer',
        minimum: -32768,
        maximum: 32767
      };
    }
    return {
      type: 'integer',
      minimum: -2147483648,
      maximum: 2147483647
    };
  }

  // Numeric/decimal types
  if (type.includes('numeric') || type.includes('decimal') || 
      type.includes('float') || type.includes('double') || type.includes('real')) {
    return { type: 'number' };
  }

  // Boolean
  if (type.includes('bool')) {
    return { type: 'boolean' };
  }

  // Date types
  if (type.includes('date') && !type.includes('time')) {
    return {
      type: 'string',
      format: 'date'
    };
  }

  // DateTime/timestamp types
  if (type.includes('timestamp') || type.includes('datetime')) {
    return {
      type: 'string',
      format: 'date-time'
    };
  }

  // Time
  if (type === 'time') {
    return {
      type: 'string',
      format: 'time'
    };
  }

  // JSON/JSONB
  if (type.includes('json')) {
    return {
      type: ['object', 'array', 'string', 'number', 'boolean', 'null']
    };
  }

  // Array types
  if (type.includes('[]') || type.includes('array')) {
    const baseType = type.replace(/\[\]|\s*array/g, '').trim();
    const itemProperty = mapTypeToJSONSchema(baseType);
    return {
      type: 'array',
      items: itemProperty
    };
  }

  // Binary/bytea
  if (type.includes('bytea') || type.includes('binary') || type.includes('blob')) {
    return {
      type: 'string',
      format: 'binary'
    };
  }

  // Enum types (basic support)
  if (type.includes('enum')) {
    return {
      type: 'string'
      // enum values would need to be parsed from type definition
    };
  }

  // Default fallback
  return { type: 'string' };
}

function parseDefaultValue(defaultExpr: string, type: string | string[]): any {
  if (!defaultExpr) return undefined;

  const expr = defaultExpr.trim();
  const typeStr = Array.isArray(type) ? type[0] : type;

  // Handle quoted strings
  if ((expr.startsWith("'") && expr.endsWith("'")) || 
      (expr.startsWith('"') && expr.endsWith('"'))) {
    return expr.slice(1, -1);
  }

  // Handle boolean
  if (typeStr === 'boolean') {
    const lower = expr.toLowerCase();
    if (lower === 'true' || lower === '1' || lower === 'yes') return true;
    if (lower === 'false' || lower === '0' || lower === 'no') return false;
  }

  // Handle numbers
  if (typeStr === 'number' || typeStr === 'integer') {
    const num = parseFloat(expr);
    if (!isNaN(num)) return num;
  }

  // Handle special functions (return as string for now)
  if (expr.includes('()') || expr.includes('now') || expr.includes('uuid')) {
    return undefined; // Don't include function calls as defaults in JSON Schema
  }

  // Return as string by default
  return expr;
}

function isAutoGenerated(attr: IRAttribute): boolean {
  // Check if this looks like an auto-generated field
  return !!(
    attr.isPrimaryKey && (
      attr.type.toLowerCase().includes('serial') ||
      attr.default?.toLowerCase().includes('uuid') ||
      attr.default?.toLowerCase().includes('nextval')
    )
  );
}