import type { IRSchema, IRDiagram, IRAttribute, IRColumn } from '../../ir';
import { validateIRSchema, validateIRDiagram } from '../../ir/validators';
import { POSTGRES_TYPES, getPostgresType } from '../../ir/mapping';

export interface SupabaseOptions {
  withRLS?: boolean;
  schema?: string;
  includeComments?: boolean;
  enableExtensions?: boolean;
}

export function toSupabaseSQL(
  ir: IRSchema | IRDiagram,
  options: SupabaseOptions = {}
): string {
  const opts = {
    withRLS: false,
    schema: 'public',
    includeComments: true,
    enableExtensions: true,
    ...options,
  };

  let sql: string;

  // Handle both new IRSchema and legacy IRDiagram formats
  if ('entities' in ir) {
    const validIR = validateIRSchema(ir);
    sql = generateFromIRSchema(validIR, opts);
  } else {
    const validIR = validateIRDiagram(ir);
    sql = generateFromIRDiagram(validIR, opts);
  }

  return sql;
}

function generateFromIRSchema(ir: IRSchema, options: SupabaseOptions): string {
  const parts: string[] = [];

  // Schema header
  parts.push('-- Supabase Schema Generated by Erdus');
  parts.push('-- Compatible with PostgreSQL 15+');
  parts.push('');

  // Extensions
  if (options.enableExtensions) {
    parts.push('-- Enable required extensions');
    parts.push("CREATE EXTENSION IF NOT EXISTS 'uuid-ossp';");
    parts.push("CREATE EXTENSION IF NOT EXISTS 'pgcrypto';");
    parts.push('');
  }

  // Create schema if not public
  if (options.schema && options.schema !== 'public') {
    parts.push(`-- Create schema`);
    parts.push(`CREATE SCHEMA IF NOT EXISTS ${options.schema};`);
    parts.push('');
  }

  // Generate enums first
  if (ir.enums && ir.enums.length > 0) {
    parts.push('-- Enums');
    for (const enumDef of ir.enums) {
      parts.push(generateEnum(enumDef, options));
    }
    parts.push('');
  }

  // Generate tables
  parts.push('-- Tables');
  for (const entity of ir.entities) {
    parts.push(generateEntityTable(entity, options));
    parts.push('');
  }

  // Generate constraints after all tables are created
  parts.push('-- Foreign key constraints');
  for (const entity of ir.entities) {
    const constraints = generateEntityConstraints(entity, options);
    if (constraints) {
      parts.push(constraints);
    }
  }

  // Generate indexes
  parts.push('-- Indexes');
  for (const entity of ir.entities) {
    const indexes = generateEntityIndexes(entity, options);
    if (indexes) {
      parts.push(indexes);
      parts.push('');
    }
  }

  // Generate RLS policies if requested
  if (options.withRLS) {
    parts.push('-- Row Level Security Policies');
    for (const entity of ir.entities) {
      parts.push(generateRLSPolicies(entity, options));
      parts.push('');
    }
  }

  return parts.join('\n');
}

function generateFromIRDiagram(ir: IRDiagram, options: SupabaseOptions): string {
  const parts: string[] = [];

  // Schema header
  parts.push('-- Supabase Schema Generated by Erdus');
  parts.push('-- Compatible with PostgreSQL 15+');
  parts.push('');

  // Extensions
  if (options.enableExtensions) {
    parts.push('-- Enable required extensions');
    parts.push("CREATE EXTENSION IF NOT EXISTS 'uuid-ossp';");
    parts.push("CREATE EXTENSION IF NOT EXISTS 'pgcrypto';");
    parts.push('');
  }

  // Create schema if not public
  if (options.schema && options.schema !== 'public') {
    parts.push(`-- Create schema`);
    parts.push(`CREATE SCHEMA IF NOT EXISTS ${options.schema};`);
    parts.push('');
  }

  // Generate tables
  parts.push('-- Tables');
  for (const table of ir.tables) {
    parts.push(generateTable(table, options));
    parts.push('');
  }

  // Generate constraints after all tables are created
  parts.push('-- Foreign key constraints');
  for (const table of ir.tables) {
    const constraints = generateTableConstraints(table, options);
    if (constraints) {
      parts.push(constraints);
    }
  }

  // Generate indexes
  parts.push('-- Indexes');
  for (const table of ir.tables) {
    const indexes = generateTableIndexes(table, options);
    if (indexes) {
      parts.push(indexes);
      parts.push('');
    }
  }

  // Generate RLS policies if requested
  if (options.withRLS) {
    parts.push('-- Row Level Security Policies');
    for (const table of ir.tables) {
      parts.push(generateTableRLSPolicies(table, options));
      parts.push('');
    }
  }

  return parts.join('\n');
}

function generateEnum(enumDef: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const values = enumDef.values.map((v: string) => `'${v}'`).join(', ');
  
  return `CREATE TYPE ${schemaPrefix}${enumDef.name} AS ENUM (${values});`;
}

function generateEntityTable(entity: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${entity.name}`;
  
  const parts: string[] = [];
  parts.push(`CREATE TABLE ${tableName} (`);

  const columnDefs = entity.attributes.map((attr: any) => 
    '  ' + generateAttributeColumn(attr, options)
  );

  // Add primary key constraint if composite
  const pkAttributes = entity.attributes.filter((attr: any) => attr.pk);
  if (pkAttributes.length > 1) {
    const pkColumns = pkAttributes.map((attr: any) => attr.name).join(', ');
    columnDefs.push(`  PRIMARY KEY (${pkColumns})`);
  }

  parts.push(columnDefs.join(',\n'));
  parts.push(');');

  // Add table comment
  if (options.includeComments && entity.comment) {
    parts.push('');
    parts.push(`COMMENT ON TABLE ${tableName} IS '${escapeSQLString(entity.comment)}';`);
  }

  // Add column comments
  if (options.includeComments) {
    for (const attr of entity.attributes) {
      if (attr.comment) {
        parts.push(`COMMENT ON COLUMN ${tableName}.${attr.name} IS '${escapeSQLString(attr.comment)}';`);
      }
    }
  }

  return parts.join('\n');
}

function generateTable(table: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${table.name}`;
  
  const parts: string[] = [];
  parts.push(`CREATE TABLE ${tableName} (`);

  const columnDefs = table.columns.map((col: any) => 
    '  ' + generateColumn(col, options)
  );

  // Add primary key constraint if composite
  if (table.primaryKey && table.primaryKey.length > 1) {
    const pkColumns = table.primaryKey.join(', ');
    columnDefs.push(`  PRIMARY KEY (${pkColumns})`);
  }

  parts.push(columnDefs.join(',\n'));
  parts.push(');');

  return parts.join('\n');
}

function generateAttributeColumn(attr: IRAttribute, options: SupabaseOptions): string {
  const parts: string[] = [];
  
  // Column name
  parts.push(attr.name);
  
  // Data type
  const dataType = getPostgresDataType(attr);
  parts.push(dataType);
  
  // NOT NULL constraint
  if (!attr.nullable) {
    parts.push('NOT NULL');
  }
  
  // DEFAULT value
  if (attr.default) {
    const defaultValue = formatPostgresDefault(attr.default, attr.type);
    parts.push(`DEFAULT ${defaultValue}`);
  }
  
  // PRIMARY KEY (for single column PKs)
  if (attr.pk && !hasCompositePK(attr)) {
    parts.push('PRIMARY KEY');
  }
  
  // UNIQUE constraint
  if (attr.unique) {
    parts.push('UNIQUE');
  }

  return parts.join(' ');
}

function generateColumn(column: IRColumn, options: SupabaseOptions): string {
  const parts: string[] = [];
  
  // Column name
  parts.push(column.name);
  
  // Data type
  const dataType = getPostgresDataTypeFromString(column.type);
  parts.push(dataType);
  
  // NOT NULL constraint
  if (!column.isOptional) {
    parts.push('NOT NULL');
  }
  
  // DEFAULT value
  if (column.default) {
    const defaultValue = formatPostgresDefault(column.default, 'string');
    parts.push(`DEFAULT ${defaultValue}`);
  }
  
  // PRIMARY KEY (for single column PKs)
  if (column.isPrimaryKey) {
    parts.push('PRIMARY KEY');
  }
  
  // UNIQUE constraint
  if (column.isUnique) {
    parts.push('UNIQUE');
  }

  return parts.join(' ');
}

function generateEntityConstraints(entity: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${entity.name}`;
  const constraints: string[] = [];

  // Foreign key constraints
  for (const attr of entity.attributes) {
    if (attr.references) {
      const constraintName = `fk_${entity.name}_${attr.name}`;
      const refTable = `${schemaPrefix}${attr.references.table}`;
      const onDelete = attr.references.onDelete ? ` ON DELETE ${attr.references.onDelete}` : '';
      const onUpdate = attr.references.onUpdate ? ` ON UPDATE ${attr.references.onUpdate}` : '';
      
      constraints.push(
        `ALTER TABLE ${tableName} ADD CONSTRAINT ${constraintName} ` +
        `FOREIGN KEY (${attr.name}) REFERENCES ${refTable}(${attr.references.column})${onDelete}${onUpdate};`
      );
    }
  }

  // Custom constraints
  if (entity.constraints) {
    for (const constraint of entity.constraints) {
      if (constraint.type === 'check' && constraint.expression) {
        const constraintName = constraint.name || `chk_${entity.name}_${constraint.columns.join('_')}`;
        constraints.push(
          `ALTER TABLE ${tableName} ADD CONSTRAINT ${constraintName} CHECK (${constraint.expression});`
        );
      }
    }
  }

  return constraints.join('\n');
}

function generateTableConstraints(table: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${table.name}`;
  const constraints: string[] = [];

  // Foreign key constraints
  for (const column of table.columns) {
    if (column.references) {
      const constraintName = `fk_${table.name}_${column.name}`;
      const refTable = `${schemaPrefix}${column.references.table}`;
      const onDelete = column.references.onDelete ? ` ON DELETE ${column.references.onDelete}` : '';
      const onUpdate = column.references.onUpdate ? ` ON UPDATE ${column.references.onUpdate}` : '';
      
      constraints.push(
        `ALTER TABLE ${tableName} ADD CONSTRAINT ${constraintName} ` +
        `FOREIGN KEY (${column.name}) REFERENCES ${refTable}(${column.references.column})${onDelete}${onUpdate};`
      );
    }
  }

  return constraints.join('\n');
}

function generateEntityIndexes(entity: any, options: SupabaseOptions): string {
  if (!entity.indexes || entity.indexes.length === 0) return '';

  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${entity.name}`;
  const indexes: string[] = [];

  for (const index of entity.indexes) {
    const indexName = index.name || `idx_${entity.name}_${index.columns.join('_')}`;
    const unique = index.unique ? 'UNIQUE ' : '';
    const using = index.type ? ` USING ${index.type}` : '';
    const columns = index.columns.join(', ');
    
    indexes.push(`CREATE ${unique}INDEX ${indexName} ON ${tableName}${using} (${columns});`);
  }

  return indexes.join('\n');
}

function generateTableIndexes(table: any, options: SupabaseOptions): string {
  if (!table.indexes || table.indexes.length === 0) return '';

  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${table.name}`;
  const indexes: string[] = [];

  for (const index of table.indexes) {
    const indexName = `idx_${table.name}_${index.columns.join('_')}`;
    const unique = index.unique ? 'UNIQUE ' : '';
    const columns = index.columns.join(', ');
    
    indexes.push(`CREATE ${unique}INDEX ${indexName} ON ${tableName} (${columns});`);
  }

  return indexes.join('\n');
}

function generateRLSPolicies(entity: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${entity.name}`;
  const policies: string[] = [];

  // Enable RLS
  policies.push(`ALTER TABLE ${tableName} ENABLE ROW LEVEL SECURITY;`);
  policies.push('');

  // Check if entity has owner_id column for owner-based policies
  const hasOwnerId = entity.attributes.some((attr: any) => attr.name === 'owner_id');
  
  if (hasOwnerId) {
    // Owner can select, update, delete their own records
    policies.push(`-- Policy: Owner can select their own records`);
    policies.push(`CREATE POLICY "owner_can_select_${entity.name}" ON ${tableName}`);
    policies.push(`  FOR SELECT USING (auth.uid() = owner_id);`);
    policies.push('');

    policies.push(`-- Policy: Owner can update their own records`);
    policies.push(`CREATE POLICY "owner_can_update_${entity.name}" ON ${tableName}`);
    policies.push(`  FOR UPDATE USING (auth.uid() = owner_id);`);
    policies.push('');

    policies.push(`-- Policy: Owner can delete their own records`);
    policies.push(`CREATE POLICY "owner_can_delete_${entity.name}" ON ${tableName}`);
    policies.push(`  FOR DELETE USING (auth.uid() = owner_id);`);
    policies.push('');

    policies.push(`-- Policy: Authenticated users can insert records`);
    policies.push(`CREATE POLICY "authenticated_can_insert_${entity.name}" ON ${tableName}`);
    policies.push(`  FOR INSERT WITH CHECK (auth.role() = 'authenticated');`);
  } else {
    // Generic authenticated user policies
    policies.push(`-- Policy: Authenticated users have full access`);
    policies.push(`CREATE POLICY "authenticated_full_access_${entity.name}" ON ${tableName}`);
    policies.push(`  FOR ALL USING (auth.role() = 'authenticated');`);
  }

  return policies.join('\n');
}

function generateTableRLSPolicies(table: any, options: SupabaseOptions): string {
  const schemaPrefix = options.schema !== 'public' ? `${options.schema}.` : '';
  const tableName = `${schemaPrefix}${table.name}`;
  const policies: string[] = [];

  // Enable RLS
  policies.push(`ALTER TABLE ${tableName} ENABLE ROW LEVEL SECURITY;`);
  policies.push('');

  // Check if table has owner_id column for owner-based policies
  const hasOwnerId = table.columns.some((col: any) => col.name === 'owner_id');
  
  if (hasOwnerId) {
    // Owner can select, update, delete their own records
    policies.push(`-- Policy: Owner can select their own records`);
    policies.push(`CREATE POLICY "owner_can_select_${table.name}" ON ${tableName}`);
    policies.push(`  FOR SELECT USING (auth.uid() = owner_id);`);
    policies.push('');

    policies.push(`-- Policy: Owner can update their own records`);
    policies.push(`CREATE POLICY "owner_can_update_${table.name}" ON ${tableName}`);
    policies.push(`  FOR UPDATE USING (auth.uid() = owner_id);`);
    policies.push('');

    policies.push(`-- Policy: Owner can delete their own records`);
    policies.push(`CREATE POLICY "owner_can_delete_${table.name}" ON ${tableName}`);
    policies.push(`  FOR DELETE USING (auth.uid() = owner_id);`);
    policies.push('');

    policies.push(`-- Policy: Authenticated users can insert records`);
    policies.push(`CREATE POLICY "authenticated_can_insert_${table.name}" ON ${tableName}`);
    policies.push(`  FOR INSERT WITH CHECK (auth.role() = 'authenticated');`);
  } else {
    // Generic authenticated user policies
    policies.push(`-- Policy: Authenticated users have full access`);
    policies.push(`CREATE POLICY "authenticated_full_access_${table.name}" ON ${tableName}`);
    policies.push(`  FOR ALL USING (auth.role() = 'authenticated');`);
  }

  return policies.join('\n');
}

function getPostgresDataType(attr: IRAttribute): string {
  let baseType = POSTGRES_TYPES[attr.type] || 'text';
  
  // Apply type modifiers
  switch (attr.type) {
    case 'string':
      if (attr.length) {
        baseType = `varchar(${attr.length})`;
      }
      break;
    case 'decimal':
      if (attr.precision && attr.scale !== undefined) {
        baseType = `numeric(${attr.precision},${attr.scale})`;
      }
      break;
    case 'integer':
      // Use serial for auto-incrementing primary keys
      if (attr.pk && attr.default === 'auto') {
        baseType = 'serial';
      }
      break;
    case 'bigint':
      if (attr.pk && attr.default === 'auto') {
        baseType = 'bigserial';
      }
      break;
  }
  
  return baseType;
}

function getPostgresDataTypeFromString(typeString: string): string {
  return getPostgresType(typeString, 'postgres');
}

function formatPostgresDefault(defaultValue: string, dataType: any): string {
  const lower = defaultValue.toLowerCase().trim();
  
  // Handle special PostgreSQL functions
  if (lower === 'now()' || lower === 'current_timestamp') {
    return 'CURRENT_TIMESTAMP';
  }
  if (lower === 'gen_random_uuid()' || lower === 'uuid_generate_v4()') {
    return 'gen_random_uuid()';
  }
  if (lower === 'true' || lower === 'false') {
    return lower;
  }
  
  // Handle numbers
  if (/^-?\d+(\.\d+)?$/.test(defaultValue)) {
    return defaultValue;
  }
  
  // Handle quoted strings - remove quotes for PostgreSQL
  if (defaultValue.startsWith("'") && defaultValue.endsWith("'")) {
    return defaultValue;
  }
  
  // Quote unquoted strings
  return `'${defaultValue.replace(/'/g, "''")}'`;
}

function hasCompositePK(attr: IRAttribute): boolean {
  // This is a simplified check - in a real implementation, 
  // you'd need to check if there are other PK attributes in the same entity
  return false;
}

function escapeSQLString(str: string): string {
  return str.replace(/'/g, "''");
}