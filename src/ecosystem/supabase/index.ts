import type { IRDiagram, IRTable, IRColumn } from '../../ir';

/**
 * Options for Supabase schema generation
 */
export interface SupabaseOptions {
  /** Include Row Level Security (RLS) policies */
  includeRLS?: boolean;
  /** Schema name for tables */
  schemaName?: string;
  /** Include audit columns (created_at, updated_at) */
  includeAuditColumns?: boolean;
  /** Include UUID extension */
  includeUUIDExtension?: boolean;
  /** Default RLS policy type */
  defaultRLSPolicy?: 'authenticated' | 'public' | 'owner-only' | 'none';
  /** Include database functions */
  includeFunctions?: boolean;
  /** Include triggers for updated_at */
  includeUpdatedAtTriggers?: boolean;
}

/**
 * RLS Policy definition
 */
interface RLSPolicy {
  name: string;
  table: string;
  operation: 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'ALL';
  role?: string;
  condition?: string;
  check?: string;
}

/**
 * Supabase schema metadata
 */
interface SupabaseSchema {
  extensions: string[];
  functions: string[];
  tables: string[];
  indexes: string[];
  triggers: string[];
  policies: RLSPolicy[];
}

/**
 * Map IR column type to PostgreSQL/Supabase type
 */
function mapColumnTypeToPostgreSQL(irType: string): string {
  const upperType = irType.toUpperCase();
  
  // Handle SERIAL types - use BIGINT with DEFAULT for Supabase
  if (upperType === 'SERIAL') {
    return 'BIGINT GENERATED BY DEFAULT AS IDENTITY';
  }
  
  if (upperType === 'BIGSERIAL') {
    return 'BIGINT GENERATED BY DEFAULT AS IDENTITY';
  }
  
  // Integer types
  if (upperType === 'INTEGER' || upperType === 'INT') {
    return 'INTEGER';
  }
  
  if (upperType === 'BIGINT') {
    return 'BIGINT';
  }
  
  if (upperType === 'SMALLINT') {
    return 'SMALLINT';
  }
  
  // Numeric types
  if (upperType.startsWith('DECIMAL') || upperType.startsWith('NUMERIC')) {
    return irType; // Keep as-is with precision
  }
  
  if (upperType === 'REAL') {
    return 'REAL';
  }
  
  if (upperType === 'DOUBLE PRECISION') {
    return 'DOUBLE PRECISION';
  }
  
  // Boolean
  if (upperType === 'BOOLEAN' || upperType === 'BOOL') {
    return 'BOOLEAN';
  }
  
  // String types
  if (upperType.startsWith('VARCHAR')) {
    return irType; // Keep with length constraint
  }
  
  if (upperType.startsWith('CHAR')) {
    return irType;
  }
  
  if (upperType === 'TEXT') {
    return 'TEXT';
  }
  
  // Date/Time types
  if (upperType.includes('TIMESTAMP')) {
    return 'TIMESTAMPTZ'; // Use timezone-aware timestamps
  }
  
  if (upperType === 'DATE') {
    return 'DATE';
  }
  
  if (upperType === 'TIME') {
    return 'TIME';
  }
  
  // UUID
  if (upperType === 'UUID') {
    return 'UUID';
  }
  
  // JSON - prefer JSONB for Supabase
  if (upperType === 'JSON' || upperType === 'JSONB') {
    return 'JSONB';
  }
  
  // Default to TEXT for unknown types
  return 'TEXT';
}

/**
 * Generate SQL column definition
 */
function generateColumnDefinition(column: IRColumn, options: SupabaseOptions): string {
  const pgType = mapColumnTypeToPostgreSQL(column.type);
  const parts: string[] = [`"${column.name}" ${pgType}`];
  
  // NOT NULL constraint
  if (!column.isOptional) {
    parts.push('NOT NULL');
  }
  
  // UNIQUE constraint
  if (column.isUnique) {
    parts.push('UNIQUE');
  }
  
  // DEFAULT value
  if (column.default !== undefined) {
    const defaultStr = column.default.toLowerCase();
    if (defaultStr.includes('now()') || defaultStr.includes('current_timestamp')) {
      parts.push('DEFAULT NOW()');
    } else if (defaultStr === 'true' || defaultStr === 'false') {
      parts.push(`DEFAULT ${defaultStr.toUpperCase()}`);
    } else if (!isNaN(Number(defaultStr))) {
      parts.push(`DEFAULT ${defaultStr}`);
    } else if (defaultStr.startsWith("'") && defaultStr.endsWith("'")) {
      parts.push(`DEFAULT ${column.default}`);
    } else {
      parts.push(`DEFAULT '${column.default}'`);
    }
  }
  
  return parts.join(' ');
}

/**
 * Generate CREATE TABLE statement
 */
function generateCreateTable(table: IRTable, options: SupabaseOptions): string {
  const schemaPrefix = (options.schemaName && options.schemaName !== 'public') ? `"${options.schemaName}".` : '';
  const lines: string[] = [];
  
  lines.push(`CREATE TABLE ${schemaPrefix}"${table.name}" (`);
  
  // Regular columns
  const columnDefs: string[] = [];
  const primaryKeyColumns: string[] = [];
  
  for (const column of table.columns) {
    columnDefs.push(`  ${generateColumnDefinition(column, options)}`);
    
    if (column.isPrimaryKey) {
      primaryKeyColumns.push(`"${column.name}"`);
    }
  }
  
  // Add audit columns if requested
  if (options.includeAuditColumns) {
    columnDefs.push('  "created_at" TIMESTAMPTZ DEFAULT NOW() NOT NULL');
    columnDefs.push('  "updated_at" TIMESTAMPTZ DEFAULT NOW() NOT NULL');
  }
  
  // Primary key constraint
  if (primaryKeyColumns.length > 0) {
    columnDefs.push(`  PRIMARY KEY (${primaryKeyColumns.join(', ')})`);
  }
  
  // Foreign key constraints
  for (const column of table.columns) {
    if (column.references) {
      const onDelete = column.references.onDelete ? ` ON DELETE ${column.references.onDelete.toUpperCase()}` : '';
      const onUpdate = column.references.onUpdate ? ` ON UPDATE ${column.references.onUpdate.toUpperCase()}` : '';
      columnDefs.push(`  FOREIGN KEY ("${column.name}") REFERENCES ${schemaPrefix}"${column.references.table}"("${column.references.column}")${onDelete}${onUpdate}`);
    }
  }
  
  lines.push(columnDefs.join(',\n'));
  lines.push(');');
  
  return lines.join('\n');
}

/**
 * Generate RLS policies for a table
 */
function generateRLSPolicies(table: IRTable, options: SupabaseOptions): RLSPolicy[] {
  if (!options.includeRLS || options.defaultRLSPolicy === 'none') {
    return [];
  }
  
  const policies: RLSPolicy[] = [];
  const schemaPrefix = (options.schemaName && options.schemaName !== 'public') ? `"${options.schemaName}".` : '';
  const tableName = `${schemaPrefix}"${table.name}"`;
  
  switch (options.defaultRLSPolicy) {
    case 'public':
      policies.push({
        name: `${table.name}_select_policy`,
        table: tableName,
        operation: 'SELECT',
        condition: 'true',
      });
      policies.push({
        name: `${table.name}_insert_policy`,
        table: tableName,
        operation: 'INSERT',
        check: 'true',
      });
      policies.push({
        name: `${table.name}_update_policy`,
        table: tableName,
        operation: 'UPDATE',
        condition: 'true',
      });
      policies.push({
        name: `${table.name}_delete_policy`,
        table: tableName,
        operation: 'DELETE',
        condition: 'true',
      });
      break;
      
    case 'authenticated':
      policies.push({
        name: `${table.name}_select_policy`,
        table: tableName,
        operation: 'SELECT',
        role: 'authenticated',
        condition: 'true',
      });
      policies.push({
        name: `${table.name}_insert_policy`,
        table: tableName,
        operation: 'INSERT',
        role: 'authenticated',
        check: 'true',
      });
      policies.push({
        name: `${table.name}_update_policy`,
        table: tableName,
        operation: 'UPDATE',
        role: 'authenticated',
        condition: 'true',
      });
      policies.push({
        name: `${table.name}_delete_policy`,
        table: tableName,
        operation: 'DELETE',
        role: 'authenticated',
        condition: 'true',
      });
      break;
      
    case 'owner-only':
      // Assumes there's a user_id column or similar
      const userColumn = table.columns.find(c => 
        c.name.includes('user_id') || 
        c.name.includes('owner_id') || 
        c.name.includes('created_by')
      );
      
      if (userColumn) {
        const condition = `"${userColumn.name}" = auth.uid()`;
        
        policies.push({
          name: `${table.name}_select_policy`,
          table: tableName,
          operation: 'SELECT',
          role: 'authenticated',
          condition,
        });
        policies.push({
          name: `${table.name}_insert_policy`,
          table: tableName,
          operation: 'INSERT',
          role: 'authenticated',
          check: `"${userColumn.name}" = auth.uid()`,
        });
        policies.push({
          name: `${table.name}_update_policy`,
          table: tableName,
          operation: 'UPDATE',
          role: 'authenticated',
          condition,
        });
        policies.push({
          name: `${table.name}_delete_policy`,
          table: tableName,
          operation: 'DELETE',
          role: 'authenticated',
          condition,
        });
      }
      break;
  }
  
  return policies;
}

/**
 * Generate SQL for RLS policy
 */
function generateRLSPolicySQL(policy: RLSPolicy): string {
  const parts: string[] = [`CREATE POLICY "${policy.name}" ON ${policy.table}`];
  
  if (policy.role) {
    parts.push(`FOR ${policy.operation} TO ${policy.role}`);
  } else {
    parts.push(`FOR ${policy.operation}`);
  }
  
  if (policy.condition) {
    parts.push(`USING (${policy.condition})`);
  }
  
  if (policy.check) {
    parts.push(`WITH CHECK (${policy.check})`);
  }
  
  return parts.join(' ') + ';';
}

/**
 * Generate indexes for a table
 */
function generateIndexes(table: IRTable, options: SupabaseOptions): string[] {
  const indexes: string[] = [];
  const schemaPrefix = (options.schemaName && options.schemaName !== 'public') ? `"${options.schemaName}".` : '';
  
  // Indexes for foreign keys
  for (const column of table.columns) {
    if (column.references) {
      const indexName = `idx_${table.name}_${column.name}`;
      indexes.push(`CREATE INDEX "${indexName}" ON ${schemaPrefix}"${table.name}" ("${column.name}");`);
    }
  }
  
  // Indexes for unique columns (if not already primary key)
  for (const column of table.columns) {
    if (column.isUnique && !column.isPrimaryKey) {
      const indexName = `idx_${table.name}_${column.name}_unique`;
      indexes.push(`CREATE UNIQUE INDEX "${indexName}" ON ${schemaPrefix}"${table.name}" ("${column.name}");`);
    }
  }
  
  // Custom indexes from table definition
  if (table.indexes) {
    for (const index of table.indexes) {
      const indexName = `idx_${table.name}_${index.columns.join('_')}`;
      const uniqueKeyword = index.unique ? 'UNIQUE ' : '';
      const columnList = index.columns.map(col => `"${col}"`).join(', ');
      indexes.push(`CREATE ${uniqueKeyword}INDEX "${indexName}" ON ${schemaPrefix}"${table.name}" (${columnList});`);
    }
  }
  
  return indexes;
}

/**
 * Generate updated_at trigger for a table
 */
function generateUpdatedAtTrigger(table: IRTable, options: SupabaseOptions): string[] {
  if (!options.includeUpdatedAtTriggers || !options.includeAuditColumns) {
    return [];
  }
  
  const schemaPrefix = (options.schemaName && options.schemaName !== 'public') ? `"${options.schemaName}".` : '';
  const triggerName = `update_${table.name}_updated_at`;
  
  return [
    `CREATE TRIGGER "${triggerName}"`,
    `  BEFORE UPDATE ON ${schemaPrefix}"${table.name}"`,
    `  FOR EACH ROW`,
    `  EXECUTE FUNCTION update_updated_at_column();`,
  ];
}

/**
 * Generate common database functions
 */
function generateDatabaseFunctions(options: SupabaseOptions): string[] {
  if (!options.includeFunctions) {
    return [];
  }
  
  const functions: string[] = [];
  
  // Updated at function
  if (options.includeUpdatedAtTriggers) {
    functions.push(`
-- Function to automatically update updated_at column
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;`);
  }
  
  return functions;
}

/**
 * Convert IR diagram to Supabase SQL schema
 * 
 * @param diagram - The IR diagram to convert
 * @param options - Configuration options for schema generation
 * @returns Generated Supabase SQL schema
 * 
 * @example
 * ```typescript
 * const diagram: IRDiagram = {
 *   tables: [
 *     {
 *       name: 'User',
 *       columns: [
 *         { name: 'id', type: 'UUID', isPrimaryKey: true },
 *         { name: 'name', type: 'VARCHAR(100)' },
 *         { name: 'email', type: 'VARCHAR(255)', isUnique: true }
 *       ]
 *     }
 *   ]
 * };
 * 
 * const schema = irToSupabase(diagram, {
 *   includeRLS: true,
 *   defaultRLSPolicy: 'authenticated',
 *   includeAuditColumns: true
 * });
 * ```
 */
export function irToSupabase(
  diagram: IRDiagram, 
  options: SupabaseOptions = {}
): string {
  const defaultOptions: Required<SupabaseOptions> = {
    includeRLS: true,
    schemaName: 'public',
    includeAuditColumns: true,
    includeUUIDExtension: true,
    defaultRLSPolicy: 'authenticated',
    includeFunctions: true,
    includeUpdatedAtTriggers: true,
    ...options,
  };
  
  const schema: SupabaseSchema = {
    extensions: [],
    functions: [],
    tables: [],
    indexes: [],
    triggers: [],
    policies: [],
  };
  
  const output: string[] = [];
  
  // Extensions
  if (defaultOptions.includeUUIDExtension) {
    output.push('-- Enable UUID extension');
    output.push('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";');
    output.push('');
  }
  
  // Functions
  const functions = generateDatabaseFunctions(defaultOptions);
  if (functions.length > 0) {
    output.push('-- Database functions');
    output.push(...functions);
    output.push('');
  }
  
  // Create tables
  output.push('-- Create tables');
  for (const table of diagram.tables) {
    output.push(generateCreateTable(table, defaultOptions));
    output.push('');
  }
  
  // Create indexes
  const allIndexes: string[] = [];
  for (const table of diagram.tables) {
    allIndexes.push(...generateIndexes(table, defaultOptions));
  }
  
  if (allIndexes.length > 0) {
    output.push('-- Create indexes');
    output.push(...allIndexes);
    output.push('');
  }
  
  // Enable RLS and create policies
  if (defaultOptions.includeRLS) {
    output.push('-- Enable Row Level Security');
    const schemaPrefix = defaultOptions.schemaName !== 'public' ? `"${defaultOptions.schemaName}".` : '';
    
    for (const table of diagram.tables) {
      output.push(`ALTER TABLE ${schemaPrefix}"${table.name}" ENABLE ROW LEVEL SECURITY;`);
    }
    output.push('');
    
    // Generate policies
    const allPolicies: RLSPolicy[] = [];
    for (const table of diagram.tables) {
      allPolicies.push(...generateRLSPolicies(table, defaultOptions));
    }
    
    if (allPolicies.length > 0) {
      output.push('-- Create RLS policies');
      for (const policy of allPolicies) {
        output.push(generateRLSPolicySQL(policy));
      }
      output.push('');
    }
  }
  
  // Create triggers
  if (defaultOptions.includeUpdatedAtTriggers) {
    const allTriggers: string[] = [];
    for (const table of diagram.tables) {
      allTriggers.push(...generateUpdatedAtTrigger(table, defaultOptions));
    }
    
    if (allTriggers.length > 0) {
      output.push('-- Create triggers');
      output.push(...allTriggers);
      output.push('');
    }
  }
  
  return output.join('\n').trim();
}

/**
 * Generate RLS policy templates for manual customization
 */
export function generateRLSPolicyTemplates(diagram: IRDiagram): string {
  const templates: string[] = [];
  
  templates.push('-- RLS Policy Templates');
  templates.push('-- Customize these policies based on your security requirements');
  templates.push('');
  
  for (const table of diagram.tables) {
    templates.push(`-- Policies for ${table.name} table`);
    templates.push(`-- SELECT: Who can read ${table.name} records?`);
    templates.push(`CREATE POLICY "${table.name}_select_policy" ON "${table.name}"`);
    templates.push(`  FOR SELECT`);
    templates.push(`  TO authenticated`);
    templates.push(`  USING (true); -- Customize this condition`);
    templates.push('');
    
    templates.push(`-- INSERT: Who can create ${table.name} records?`);
    templates.push(`CREATE POLICY "${table.name}_insert_policy" ON "${table.name}"`);
    templates.push(`  FOR INSERT`);
    templates.push(`  TO authenticated`);
    templates.push(`  WITH CHECK (true); -- Customize this condition`);
    templates.push('');
    
    templates.push(`-- UPDATE: Who can modify ${table.name} records?`);
    templates.push(`CREATE POLICY "${table.name}_update_policy" ON "${table.name}"`);
    templates.push(`  FOR UPDATE`);
    templates.push(`  TO authenticated`);
    templates.push(`  USING (true); -- Customize this condition`);
    templates.push('');
    
    templates.push(`-- DELETE: Who can delete ${table.name} records?`);
    templates.push(`CREATE POLICY "${table.name}_delete_policy" ON "${table.name}"`);
    templates.push(`  FOR DELETE`);
    templates.push(`  TO authenticated`);
    templates.push(`  USING (true); -- Customize this condition`);
    templates.push('');
  }
  
  return templates.join('\n');
}