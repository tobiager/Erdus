import { ERProject } from '../../types';
import { exportPostgreSQL } from './sql/postgres';
import { exportMySQL } from './sql/mysql';
import { exportPrisma } from './prisma';
import { exportDBML } from './dbml';
import { exportMermaid } from './mermaid';

export type ExportFormat = 
  | 'postgres' | 'mysql' | 'mssql' | 'sqlite'  // SQL dialects
  | 'prisma' | 'typeorm' | 'dbml' | 'mermaid'  // Other formats
  | 'json';  // JSON export

export interface ExportResult {
  content: string;
  filename: string;
  mimeType: string;
}

export function exportProject(project: ERProject, format: ExportFormat): ExportResult {
  let content: string;
  let filename: string;
  let mimeType: string;

  const projectSlug = project.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString().split('T')[0];

  switch (format) {
    case 'postgres':
      content = exportPostgreSQL(project);
      filename = `${projectSlug}-postgres-${timestamp}.sql`;
      mimeType = 'text/sql';
      break;

    case 'mysql':
      content = exportMySQL(project);
      filename = `${projectSlug}-mysql-${timestamp}.sql`;
      mimeType = 'text/sql';
      break;

    case 'mssql':
      content = exportSQLServer(project);
      filename = `${projectSlug}-mssql-${timestamp}.sql`;
      mimeType = 'text/sql';
      break;

    case 'sqlite':
      content = exportSQLite(project);
      filename = `${projectSlug}-sqlite-${timestamp}.sql`;
      mimeType = 'text/sql';
      break;

    case 'prisma':
      content = exportPrisma(project);
      filename = `schema-${timestamp}.prisma`;
      mimeType = 'text/plain';
      break;

    case 'typeorm':
      content = exportTypeORM(project);
      filename = `entities-${timestamp}.ts`;
      mimeType = 'text/typescript';
      break;

    case 'dbml':
      content = exportDBML(project);
      filename = `${projectSlug}-${timestamp}.dbml`;
      mimeType = 'text/plain';
      break;

    case 'mermaid':
      content = exportMermaid(project);
      filename = `${projectSlug}-${timestamp}.mmd`;
      mimeType = 'text/plain';
      break;

    case 'json':
      content = JSON.stringify(project, null, 2);
      filename = `${projectSlug}-${timestamp}.erdus.json`;
      mimeType = 'application/json';
      break;

    default:
      throw new Error(`Unsupported export format: ${format}`);
  }

  return { content, filename, mimeType };
}

// Placeholder SQL Server exporter
function exportSQLServer(project: ERProject): string {
  // TODO: Implement SQL Server specific export
  // For now, use PostgreSQL with modifications
  let sql = exportPostgreSQL(project);
  
  // Basic SQL Server adaptations
  sql = sql.replace(/SERIAL/g, 'INT IDENTITY(1,1)');
  sql = sql.replace(/BIGSERIAL/g, 'BIGINT IDENTITY(1,1)');
  sql = sql.replace(/BOOLEAN/g, 'BIT');
  sql = sql.replace(/TEXT/g, 'NVARCHAR(MAX)');
  sql = sql.replace(/VARCHAR\((\d+)\)/g, 'NVARCHAR($1)');
  sql = sql.replace(/TIMESTAMPTZ/g, 'DATETIMEOFFSET');
  sql = sql.replace(/UUID/g, 'UNIQUEIDENTIFIER');
  
  return sql;
}

// Placeholder SQLite exporter
function exportSQLite(project: ERProject): string {
  // TODO: Implement SQLite specific export
  // For now, use PostgreSQL with modifications
  let sql = exportPostgreSQL(project);
  
  // Basic SQLite adaptations
  sql = sql.replace(/SERIAL/g, 'INTEGER');
  sql = sql.replace(/BIGSERIAL/g, 'INTEGER');
  sql = sql.replace(/SMALLINT/g, 'INTEGER');
  sql = sql.replace(/BIGINT/g, 'INTEGER');
  sql = sql.replace(/DECIMAL/g, 'REAL');
  sql = sql.replace(/DOUBLE PRECISION/g, 'REAL');
  sql = sql.replace(/BOOLEAN/g, 'INTEGER');
  sql = sql.replace(/TIMESTAMPTZ/g, 'TEXT');
  sql = sql.replace(/UUID/g, 'TEXT');
  sql = sql.replace(/JSONB?/g, 'TEXT');
  sql = sql.replace(/BYTEA/g, 'BLOB');
  
  return sql;
}

// Placeholder TypeORM exporter
function exportTypeORM(project: ERProject): string {
  // TODO: Implement full TypeORM export
  const header = `// Generated by Erdus\n// Project: ${project.name}\n// Generated: ${new Date().toISOString()}\n\n`;
  
  let typeorm = header;
  typeorm += 'import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, OneToMany, JoinColumn } from "typeorm";\n\n';
  
  if (!project.schemas[0]?.tables.length) {
    return typeorm + '// No tables to export\n';
  }
  
  for (const table of project.schemas[0].tables) {
    typeorm += `@Entity("${table.name}")\n`;
    typeorm += `export class ${toPascalCase(table.name)} {\n`;
    
    for (const column of table.columns) {
      if (column.isPrimaryKey && column.type === 'serial') {
        typeorm += '  @PrimaryGeneratedColumn()\n';
      } else if (column.isPrimaryKey) {
        typeorm += '  @PrimaryColumn()\n';
      } else {
        const columnOptions: string[] = [];
        if (column.isUnique) columnOptions.push('unique: true');
        if (!column.isOptional) columnOptions.push('nullable: false');
        if (column.default) columnOptions.push(`default: "${column.default}"`);
        
        const options = columnOptions.length > 0 ? `{ ${columnOptions.join(', ')} }` : '';
        typeorm += `  @Column(${options})\n`;
      }
      
      const tsType = mapTypeScriptType(column.type);
      const optional = column.isOptional && !column.isPrimaryKey ? '?' : '';
      typeorm += `  ${column.name}${optional}: ${tsType};\n\n`;
    }
    
    typeorm += '}\n\n';
  }
  
  return typeorm;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function mapTypeScriptType(sqlType: string): string {
  const type = sqlType.toLowerCase();
  
  switch (type) {
    case 'serial':
    case 'integer':
    case 'int':
    case 'bigint':
    case 'smallint':
    case 'decimal':
    case 'numeric':
    case 'float':
    case 'real':
    case 'double':
      return 'number';
    case 'varchar':
    case 'char':
    case 'text':
    case 'uuid':
      return 'string';
    case 'boolean':
    case 'bool':
      return 'boolean';
    case 'date':
    case 'datetime':
    case 'timestamp':
    case 'timestamptz':
      return 'Date';
    case 'json':
    case 'jsonb':
      return 'any';
    case 'bytea':
    case 'blob':
      return 'Buffer';
    default:
      return 'string';
  }
}

export function downloadFile(result: ExportResult): void {
  const blob = new Blob([result.content], { type: result.mimeType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = result.filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}