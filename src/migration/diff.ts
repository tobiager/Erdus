import { z } from 'zod';
import { IRDiagram, IRTable, IRColumn } from '../ir';
import { MigrationOptions, MigrationResult, MigrationOptionsSchema } from '../types';

export interface DiffResult {
  tablesToAdd: IRTable[];
  tablesToDrop: string[];
  tablesToModify: TableModification[];
}

export interface TableModification {
  tableName: string;
  columnsToAdd: IRColumn[];
  columnsToDrop: string[];
  columnsToModify: ColumnModification[];
  indexesToAdd: IndexDefinition[];
  indexesToDrop: string[];
  constraintsToAdd: ConstraintDefinition[];
  constraintsToDrop: string[];
}

export interface ColumnModification {
  columnName: string;
  oldColumn: IRColumn;
  newColumn: IRColumn;
  changes: ('type' | 'nullable' | 'default' | 'unique')[];
}

export interface IndexDefinition {
  name: string;
  columns: string[];
  unique: boolean;
}

export interface ConstraintDefinition {
  name: string;
  type: 'primary_key' | 'foreign_key' | 'unique' | 'check';
  definition: string;
}

/**
 * Compare two IR diagrams and generate a diff
 */
export function diffIRDiagrams(oldDiagram: IRDiagram, newDiagram: IRDiagram): DiffResult {
  const result: DiffResult = {
    tablesToAdd: [],
    tablesToDrop: [],
    tablesToModify: []
  };

  const oldTableMap = new Map(oldDiagram.tables.map(t => [t.name, t]));
  const newTableMap = new Map(newDiagram.tables.map(t => [t.name, t]));

  // Find tables to add
  for (const newTable of newDiagram.tables) {
    if (!oldTableMap.has(newTable.name)) {
      result.tablesToAdd.push(newTable);
    }
  }

  // Find tables to drop
  for (const oldTable of oldDiagram.tables) {
    if (!newTableMap.has(oldTable.name)) {
      result.tablesToDrop.push(oldTable.name);
    }
  }

  // Find tables to modify
  for (const [tableName, newTable] of newTableMap) {
    const oldTable = oldTableMap.get(tableName);
    if (oldTable) {
      const modification = diffTables(oldTable, newTable);
      if (modification) {
        result.tablesToModify.push(modification);
      }
    }
  }

  return result;
}

function diffTables(oldTable: IRTable, newTable: IRTable): TableModification | null {
  const modification: TableModification = {
    tableName: newTable.name,
    columnsToAdd: [],
    columnsToDrop: [],
    columnsToModify: [],
    indexesToAdd: [],
    indexesToDrop: [],
    constraintsToAdd: [],
    constraintsToDrop: []
  };

  const oldColumnMap = new Map(oldTable.columns.map(c => [c.name, c]));
  const newColumnMap = new Map(newTable.columns.map(c => [c.name, c]));

  // Find columns to add
  for (const newColumn of newTable.columns) {
    if (!oldColumnMap.has(newColumn.name)) {
      modification.columnsToAdd.push(newColumn);
    }
  }

  // Find columns to drop
  for (const oldColumn of oldTable.columns) {
    if (!newColumnMap.has(oldColumn.name)) {
      modification.columnsToDrop.push(oldColumn.name);
    }
  }

  // Find columns to modify
  for (const [columnName, newColumn] of newColumnMap) {
    const oldColumn = oldColumnMap.get(columnName);
    if (oldColumn) {
      const columnMod = diffColumns(oldColumn, newColumn);
      if (columnMod) {
        modification.columnsToModify.push(columnMod);
      }
    }
  }

  // Check if there are any changes
  const hasChanges = modification.columnsToAdd.length > 0 ||
                    modification.columnsToDrop.length > 0 ||
                    modification.columnsToModify.length > 0 ||
                    modification.indexesToAdd.length > 0 ||
                    modification.indexesToDrop.length > 0 ||
                    modification.constraintsToAdd.length > 0 ||
                    modification.constraintsToDrop.length > 0;

  return hasChanges ? modification : null;
}

function diffColumns(oldColumn: IRColumn, newColumn: IRColumn): ColumnModification | null {
  const changes: ('type' | 'nullable' | 'default' | 'unique')[] = [];

  if (oldColumn.type !== newColumn.type) {
    changes.push('type');
  }

  if (oldColumn.isOptional !== newColumn.isOptional) {
    changes.push('nullable');
  }

  if (oldColumn.default !== newColumn.default) {
    changes.push('default');
  }

  if (oldColumn.isUnique !== newColumn.isUnique) {
    changes.push('unique');
  }

  return changes.length > 0 ? {
    columnName: newColumn.name,
    oldColumn,
    newColumn,
    changes
  } : null;
}

/**
 * Generate safe migration SQL from diff result
 */
export function generateMigrationSQL(diff: DiffResult, options: MigrationOptions = {}): MigrationResult {
  const opts = MigrationOptionsSchema.parse(options);
  const statements: string[] = [];
  const warnings: string[] = [];
  const errors: string[] = [];

  try {
    // Add header comment if enabled
    if (opts.includeComments) {
      statements.push('-- Database Migration Script');
      statements.push('-- Generated by Erdus Migration Tool');
      statements.push(`-- Target Engine: ${opts.targetEngine}`);
      if (opts.dryRun) {
        statements.push('-- DRY RUN MODE - Review before executing');
      }
      statements.push('');
    }

    // Begin transaction for safety
    if (!opts.dryRun) {
      statements.push('BEGIN;');
      statements.push('');
    }

    // Drop constraints first (to avoid dependency issues)
    statements.push(...generateConstraintDropStatements(diff, opts, warnings));

    // Drop tables
    statements.push(...generateTableDropStatements(diff, opts, warnings));

    // Create new tables
    statements.push(...generateTableCreateStatements(diff, opts, warnings));

    // Modify existing tables
    statements.push(...generateTableModificationStatements(diff, opts, warnings, errors));

    // Add constraints last
    statements.push(...generateConstraintAddStatements(diff, opts, warnings));

    // Commit transaction
    if (!opts.dryRun) {
      statements.push('');
      statements.push('COMMIT;');
    }

    return {
      success: errors.length === 0,
      sql: statements.join('\n'),
      warnings,
      errors
    };

  } catch (error) {
    errors.push(`Migration generation error: ${error instanceof Error ? error.message : String(error)}`);
    return {
      success: false,
      warnings,
      errors
    };
  }
}

function generateConstraintDropStatements(diff: DiffResult, options: MigrationOptions, warnings: string[]): string[] {
  const statements: string[] = [];

  // Drop foreign key constraints from tables to be modified
  for (const modification of diff.tablesToModify) {
    for (const constraintName of modification.constraintsToDrop) {
      if (options.includeComments) {
        statements.push(`-- Drop constraint: ${constraintName}`);
      }
      statements.push(`ALTER TABLE "${modification.tableName}" DROP CONSTRAINT IF EXISTS "${constraintName}";`);
    }
  }

  if (statements.length > 0) {
    statements.push('');
  }

  return statements;
}

function generateTableDropStatements(diff: DiffResult, options: MigrationOptions, warnings: string[]): string[] {
  const statements: string[] = [];

  for (const tableName of diff.tablesToDrop) {
    warnings.push(`Dropping table: ${tableName} - This will permanently delete all data!`);
    
    if (options.includeComments) {
      statements.push(`-- Drop table: ${tableName}`);
      statements.push('-- WARNING: This will permanently delete all data in this table!');
    }
    statements.push(`DROP TABLE IF EXISTS "${tableName}";`);
  }

  if (statements.length > 0) {
    statements.push('');
  }

  return statements;
}

function generateTableCreateStatements(diff: DiffResult, options: MigrationOptions, warnings: string[]): string[] {
  const statements: string[] = [];

  for (const table of diff.tablesToAdd) {
    if (options.includeComments) {
      statements.push(`-- Create table: ${table.name}`);
    }
    statements.push(generateCreateTableSQL(table, options));
    statements.push('');
  }

  return statements;
}

function generateTableModificationStatements(diff: DiffResult, options: MigrationOptions, warnings: string[], errors: string[]): string[] {
  const statements: string[] = [];

  for (const modification of diff.tablesToModify) {
    if (options.includeComments) {
      statements.push(`-- Modify table: ${modification.tableName}`);
    }

    // Add new columns
    for (const column of modification.columnsToAdd) {
      if (options.includeComments) {
        statements.push(`-- Add column: ${column.name}`);
      }
      statements.push(`ALTER TABLE "${modification.tableName}" ADD COLUMN ${generateColumnDefinition(column, options)};`);
    }

    // Drop columns
    for (const columnName of modification.columnsToDrop) {
      warnings.push(`Dropping column: ${modification.tableName}.${columnName} - This will permanently delete all data in this column!`);
      
      if (options.includeComments) {
        statements.push(`-- Drop column: ${columnName}`);
        statements.push('-- WARNING: This will permanently delete all data in this column!');
      }
      statements.push(`ALTER TABLE "${modification.tableName}" DROP COLUMN IF EXISTS "${columnName}";`);
    }

    // Modify columns
    for (const columnMod of modification.columnsToModify) {
      statements.push(...generateColumnModificationSQL(modification.tableName, columnMod, options, warnings, errors));
    }

    if (modification.columnsToAdd.length > 0 || 
        modification.columnsToDrop.length > 0 || 
        modification.columnsToModify.length > 0) {
      statements.push('');
    }
  }

  return statements;
}

function generateConstraintAddStatements(diff: DiffResult, options: MigrationOptions, warnings: string[]): string[] {
  const statements: string[] = [];

  // Add foreign key constraints for new tables and modified tables
  for (const table of diff.tablesToAdd) {
    statements.push(...generateForeignKeyConstraints(table, options));
  }

  for (const modification of diff.tablesToModify) {
    for (const constraint of modification.constraintsToAdd) {
      if (options.includeComments) {
        statements.push(`-- Add constraint: ${constraint.name}`);
      }
      statements.push(`ALTER TABLE "${modification.tableName}" ADD CONSTRAINT "${constraint.name}" ${constraint.definition};`);
    }
  }

  return statements;
}

function generateCreateTableSQL(table: IRTable, options: MigrationOptions): string {
  const lines: string[] = [];
  lines.push(`CREATE TABLE "${table.name}" (`);

  const columnLines: string[] = [];
  for (const column of table.columns) {
    columnLines.push(`  ${generateColumnDefinition(column, options)}`);
  }

  // Add primary key constraint
  const pkColumns = table.primaryKey || table.columns.filter(c => c.isPrimaryKey).map(c => c.name);
  if (pkColumns.length > 0) {
    columnLines.push(`  PRIMARY KEY (${pkColumns.map(c => `"${c}"`).join(', ')})`);
  }

  lines.push(columnLines.join(',\n'));
  lines.push(');');

  return lines.join('\n');
}

function generateColumnDefinition(column: IRColumn, options: MigrationOptions): string {
  let definition = `"${column.name}" ${mapTypeForTarget(column.type, options.targetEngine!)}`;

  if (!column.isOptional) {
    definition += ' NOT NULL';
  }

  if (column.default) {
    if (column.default === 'autoincrement()') {
      // Handle auto-increment based on target engine
      switch (options.targetEngine) {
        case 'postgresql':
          definition = `"${column.name}" SERIAL`;
          break;
        case 'mysql':
          definition += ' AUTO_INCREMENT';
          break;
        case 'sqlserver':
          definition += ' IDENTITY(1,1)';
          break;
        case 'oracle':
          // Oracle uses sequences and triggers
          break;
        case 'sqlite':
          if (column.type === 'Int') {
            definition = `"${column.name}" INTEGER PRIMARY KEY AUTOINCREMENT`;
          }
          break;
      }
    } else {
      definition += ` DEFAULT ${column.default}`;
    }
  }

  if (column.isUnique && !column.isPrimaryKey) {
    definition += ' UNIQUE';
  }

  return definition;
}

function generateColumnModificationSQL(tableName: string, columnMod: ColumnModification, options: MigrationOptions, warnings: string[], errors: string[]): string[] {
  const statements: string[] = [];

  // Type changes are complex and potentially dangerous
  if (columnMod.changes.includes('type')) {
    warnings.push(`Changing column type: ${tableName}.${columnMod.columnName} from ${columnMod.oldColumn.type} to ${columnMod.newColumn.type} - This may cause data loss!`);
    
    if (options.includeComments) {
      statements.push(`-- Change column type: ${columnMod.columnName}`);
      statements.push('-- WARNING: This may cause data loss if the new type is incompatible!');
    }
    
    switch (options.targetEngine) {
      case 'postgresql':
        statements.push(`ALTER TABLE "${tableName}" ALTER COLUMN "${columnMod.columnName}" TYPE ${mapTypeForTarget(columnMod.newColumn.type, 'postgresql')};`);
        break;
      case 'mysql':
        statements.push(`ALTER TABLE "${tableName}" MODIFY COLUMN "${columnMod.columnName}" ${mapTypeForTarget(columnMod.newColumn.type, 'mysql')};`);
        break;
      case 'sqlserver':
        statements.push(`ALTER TABLE "${tableName}" ALTER COLUMN "${columnMod.columnName}" ${mapTypeForTarget(columnMod.newColumn.type, 'sqlserver')};`);
        break;
      default:
        errors.push(`Column type modification not supported for ${options.targetEngine}`);
    }
  }

  // Nullable changes
  if (columnMod.changes.includes('nullable')) {
    if (options.includeComments) {
      statements.push(`-- Change nullable: ${columnMod.columnName}`);
    }
    
    const nullConstraint = columnMod.newColumn.isOptional ? 'DROP NOT NULL' : 'SET NOT NULL';
    
    switch (options.targetEngine) {
      case 'postgresql':
        statements.push(`ALTER TABLE "${tableName}" ALTER COLUMN "${columnMod.columnName}" ${nullConstraint};`);
        break;
      case 'mysql':
        const nullKeyword = columnMod.newColumn.isOptional ? 'NULL' : 'NOT NULL';
        statements.push(`ALTER TABLE "${tableName}" MODIFY COLUMN "${columnMod.columnName}" ${mapTypeForTarget(columnMod.newColumn.type, 'mysql')} ${nullKeyword};`);
        break;
      case 'sqlserver':
        const nullConstraintSQL = columnMod.newColumn.isOptional ? 'NULL' : 'NOT NULL';
        statements.push(`ALTER TABLE "${tableName}" ALTER COLUMN "${columnMod.columnName}" ${mapTypeForTarget(columnMod.newColumn.type, 'sqlserver')} ${nullConstraintSQL};`);
        break;
      default:
        errors.push(`Nullable modification not supported for ${options.targetEngine}`);
    }
  }

  // Default value changes
  if (columnMod.changes.includes('default')) {
    if (options.includeComments) {
      statements.push(`-- Change default value: ${columnMod.columnName}`);
    }
    
    // Drop old default first
    switch (options.targetEngine) {
      case 'postgresql':
        statements.push(`ALTER TABLE "${tableName}" ALTER COLUMN "${columnMod.columnName}" DROP DEFAULT;`);
        if (columnMod.newColumn.default) {
          statements.push(`ALTER TABLE "${tableName}" ALTER COLUMN "${columnMod.columnName}" SET DEFAULT ${columnMod.newColumn.default};`);
        }
        break;
      case 'mysql':
        const defaultValue = columnMod.newColumn.default ? ` DEFAULT ${columnMod.newColumn.default}` : '';
        statements.push(`ALTER TABLE "${tableName}" MODIFY COLUMN "${columnMod.columnName}" ${mapTypeForTarget(columnMod.newColumn.type, 'mysql')}${defaultValue};`);
        break;
      default:
        errors.push(`Default value modification not supported for ${options.targetEngine}`);
    }
  }

  return statements;
}

function generateForeignKeyConstraints(table: IRTable, options: MigrationOptions): string[] {
  const statements: string[] = [];

  for (const column of table.columns) {
    if (column.references) {
      if (options.includeComments) {
        statements.push(`-- Foreign key: ${table.name}.${column.name} -> ${column.references.table}.${column.references.column}`);
      }
      
      let stmt = `ALTER TABLE "${table.name}" ADD CONSTRAINT "fk_${table.name}_${column.name}" `;
      stmt += `FOREIGN KEY ("${column.name}") REFERENCES "${column.references.table}" ("${column.references.column}")`;
      
      if (column.references.onDelete) {
        stmt += ` ON DELETE ${column.references.onDelete}`;
      }
      
      if (column.references.onUpdate) {
        stmt += ` ON UPDATE ${column.references.onUpdate}`;
      }
      
      stmt += ';';
      statements.push(stmt);
    }
  }

  return statements;
}

function mapTypeForTarget(irType: string, targetEngine: string): string {
  const typeMappings: Record<string, Record<string, string>> = {
    postgresql: {
      'Int': 'INTEGER',
      'BigInt': 'BIGINT',
      'SmallInt': 'SMALLINT',
      'String': 'VARCHAR(255)',
      'Boolean': 'BOOLEAN',
      'DateTime': 'TIMESTAMP',
      'Date': 'DATE',
      'Time': 'TIME',
      'Decimal': 'DECIMAL',
      'Float': 'REAL',
      'Double': 'DOUBLE PRECISION',
      'Json': 'JSONB'
    },
    mysql: {
      'Int': 'INT',
      'BigInt': 'BIGINT',
      'SmallInt': 'SMALLINT',
      'String': 'VARCHAR(255)',
      'Boolean': 'BOOLEAN',
      'DateTime': 'DATETIME',
      'Date': 'DATE',
      'Time': 'TIME',
      'Decimal': 'DECIMAL(10,2)',
      'Float': 'FLOAT',
      'Double': 'DOUBLE',
      'Json': 'JSON'
    },
    sqlserver: {
      'Int': 'INT',
      'BigInt': 'BIGINT',
      'SmallInt': 'SMALLINT',
      'String': 'NVARCHAR(255)',
      'Boolean': 'BIT',
      'DateTime': 'DATETIME2',
      'Date': 'DATE',
      'Time': 'TIME',
      'Decimal': 'DECIMAL(18,2)',
      'Float': 'FLOAT',
      'Double': 'FLOAT',
      'Json': 'NVARCHAR(MAX)'
    },
    oracle: {
      'Int': 'NUMBER(10)',
      'BigInt': 'NUMBER(19)',
      'SmallInt': 'NUMBER(5)',
      'String': 'VARCHAR2(255)',
      'Boolean': 'NUMBER(1)',
      'DateTime': 'TIMESTAMP',
      'Date': 'DATE',
      'Time': 'VARCHAR2(8)',
      'Decimal': 'NUMBER(10,2)',
      'Float': 'BINARY_FLOAT',
      'Double': 'BINARY_DOUBLE',
      'Json': 'CLOB'
    },
    sqlite: {
      'Int': 'INTEGER',
      'BigInt': 'INTEGER',
      'SmallInt': 'INTEGER',
      'String': 'TEXT',
      'Boolean': 'INTEGER',
      'DateTime': 'TEXT',
      'Date': 'TEXT',
      'Time': 'TEXT',
      'Decimal': 'REAL',
      'Float': 'REAL',
      'Double': 'REAL',
      'Json': 'TEXT'
    }
  };

  return typeMappings[targetEngine]?.[irType] || irType;
}